(in-ns 'timl.core)

(defn not-empty [xs] (when (seq xs) xs))

(defn filter [pred coll]
  (lazy-seq
    (loop [s (seq coll)]
      (when s
        (if (chunked-seq? s)
          (concat
            (#*timl#coll#mutating_filter pred (chunk-first s))
            (filter pred (chunk-rest s)))
          (let [f (first s) r (rest s)]
            (if (pred f)
              (cons f (filter pred r))
              (recur (seq r)))))))))

(defn iterate [f x]
  (cons x (lazy-seq (iterate f (f x)))))

(defn repeat
  ([x] (lazy-seq (cons x (repeat x))))
  ([n x] (take n (repeat x))))

(defn every?
  [pred coll]
  (cond
   (nil? (seq coll)) true
   (pred (first coll)) (recur pred (next coll))
   :else false))

(defn range
  ([] (range 0 Infinity 1))
  ([end] (range 0 end 1))
  ([start end] (range start end 1))
  ([start end step]
   (let [comp (if (pos? step) < >)
         closest #(if (comp % %2) % %2)
         next-start (closest end (+ start (* 1024 step)))]
     (if (comp start end)
       (if (integer? next-start)
         (chunk-cons
           (#*range start (dec next-start) step)
           (lazy-seq (range next-start end step)))
         (cons start (range (+ start step) end step)))
       ()))))

(defn reductions [f init xs]
  (cons init
        (lazy-seq
          (if xs
            (reductions f (f init (first xs)) (rest xs))))))

(defn last [xs] (if (next xs) (recur (next xs)) (first xs)))
(defn butlast [s]
  (loop [ret '() s s]
    (if (next s)
      (recur (conj ret (first s)) (next s))
      ret)))

(defn remove
  [pred coll]
  (filter (complement pred) coll))

(defn some
  [pred coll]
  (when (seq coll)
    (or (pred (first coll)) (recur pred (next coll)))))

(defn mapcat
  [f & colls]
  (apply concat (apply map f colls)))

(defn take-while
  [pred coll]
  (lazy-seq
   (when-let [s (seq coll)]
       (when (pred (first s))
         (cons (first s) (take-while pred (rest s)))))))

(defn drop-last
  ([s] (drop-last 1 s))
  ([n s] (map (fn [x _] x) s (drop n s))))

(defn take-last
  [n coll]
  (loop [s (seq coll), lead (seq (drop n coll))]
    (if lead
      (recur (next s) (next lead))
      s)))

(defn drop-while
  [pred coll]
  (let [step (fn [pred coll]
               (let [s (seq coll)]
                 (if (and s (pred (first s)))
                   (recur pred (rest s))
                   s)))]
    (lazy-seq (step pred coll))))

(defn cycle
  [coll] (lazy-seq 
          (when-let [s (seq coll)] 
              (concat s (cycle s)))))

(defn split-at
  [n coll]
    [(take n coll) (drop n coll)])

(defn split-with
  [pred coll]
    [(take-while pred coll) (drop-while pred coll)])

(defn nthrest
  [coll n]
    (loop [n n xs coll]
      (if (and (pos? n) (seq xs))
        (recur (dec n) (rest xs))
        xs)))

(defn take-nth
  [n coll]
    (lazy-seq
     (when-let [s (seq coll)]
       (cons (first s) (take-nth n (drop n s))))))

(defn interleave
  ([] ())
  ([c1] (lazy-seq c1))
  ([c1 c2]
     (lazy-seq
      (let [s1 (seq c1) s2 (seq c2)]
        (when (and s1 s2)
          (cons (first s1) (cons (first s2) 
                                 (interleave (rest s1) (rest s2))))))))
  ([c1 c2 & colls] 
     (lazy-seq 
      (let [ss (map seq (conj colls c2 c1))]
        (when (every? identity ss)
          (concat (map first ss) (apply interleave (map rest ss))))))))

