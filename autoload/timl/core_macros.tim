(in-ns 'timl.core)

(defmacro defonce [name expr]
  `(when-not (exists? (munge (str "g:" (ns-name *ns*) "#" '~name)))
     (def ~name ~expr)))

(defmacro if-not
  ([cond then] `(if ~cond nil ~then))
  ([cond then else] `(if ~cond ~else ~then)))

(defmacro when-not [cond & body]
  (list 'if cond nil (cons 'do body)))

(defmacro cond [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (first (rest clauses))
          (cons `cond (rest (rest clauses))))))

(defmacro -> [x & forms]
  (if (seq forms)
    (let [form (first forms)
          more (next forms)] (if more `(-> (-> ~x ~form) ~@more) (if (list? form)
          `(~(first form) ~x ~@(rest form))
          (list form x))))
    x))

(defmacro binding [bindings & body]
  (if (seq bindings)
    `(let [old# ~(first bindings)]
       (try
         (set! ~(first bindings) ~(first (rest bindings)))
         (binding ~(vec (rest (rest bindings))) ~@body)
         (finally (set! ~(first bindings) old#))))
    `(do ~@body)))

(defmacro with-out-str [& body]
  `(let [tempname# (#*tempname)]
     (execute "redraw")
     (binding [&verbosefile tempname#]
       (set! l:TimLfn (fn [] ~@body))
       (execute "silent call timl#invoke(l:TimLfn)"))
     (#*substitute (slurp tempname#) "^\n" "" "g")))

(defmacro time [& body]
  `(let [reltime# (#*reltime)
        result# (do ~@body)]
     (printf "Elapsed time: %s secs\n" (#*reltimestr (#*reltime reltime#)))
     result#))

(defmacro comment [& body])

(defmacro doseq
  [seq-exprs & body]
  #_(assert-args
     (vector? seq-exprs) "a vector for its binding"
     (even? (count seq-exprs)) "an even number of forms in binding vector")
  (let [step (fn step [recform exprs]
               (if-not exprs
                 [true `(do ~@body)]
                 (let [k (first exprs)
                       v (second exprs)]
                   (if (keyword? k)
                     (let [steppair (step recform (nnext exprs))
                           needrec (steppair 0)
                           subform (steppair 1)]
                       (cond
                         (= k :let) [needrec `(let ~v ~subform)]
                         (= k :while) [false `(when ~v
                                                ~subform
                                                ~@(when needrec [recform]))]
                         (= k :when) [false `(if ~v
                                               (do
                                                 ~subform
                                                 ~@(when needrec [recform]))
                                               ~recform)]))
                     (let [seq- (gensym "seq_")
                           chunk- (gensym "chunk_")
                           count- (gensym "count_")
                           i- (gensym "i_")
                           recform `(recur (next ~seq-) nil 0 0)
                           steppair (step recform (nnext exprs))
                           needrec (steppair 0)
                           subform (steppair 1)
                           recform-chunk 
                             `(recur ~seq- ~chunk- ~count- (inc ~i-)) ;unchecked-inc in Clojure
                           steppair-chunk (step recform-chunk (nnext exprs))
                           subform-chunk (steppair-chunk 1)]
                       [true
                        `(loop [~seq- (seq ~v), ~chunk- nil,
                                ~count- 0, ~i- 0]
                           (if (< ~i- ~count-)
                             (let [~k (nth ~chunk- ~i-)]
                               ~subform-chunk
                               ~@(when needrec [recform-chunk]))
                             (when-let [~seq- (seq ~seq-)]
                               (if (chunked-seq? ~seq-)
                                 (let [c# (chunk-first ~seq-)]
                                   (recur (chunk-rest ~seq-) c#
                                          (int (count c#)) (int 0)))
                                 (let [~k (first ~seq-)]
                                   ~subform
                                   ~@(when needrec [recform]))))))])))))]
    (nth (step nil (seq seq-exprs)) 1)))

(defmacro dotimes
  [bindings & body]
  #_(assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
  (let [i (first bindings)
        n (second bindings)]
    `(let [n# (int ~n)] ; Clojure uses (long ~n)
       (loop [~i 0]
         (when (< ~i n#)
           ~@body
           (recur (inc ~i))))))) ;Clojure uses (unchecked-inc ~i)

(defmacro when-first
  [bindings & body]
  #_(assert-args
     (vector? bindings) "a vector for its binding"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
  (let [[x xs] bindings]
    `(when-let [xs# (seq ~xs)]
       (let [~x (first xs#)]
           ~@body))))

(defmacro lazy-cat
  [& colls]
  `(concat ~@(map #(list `lazy-seq %) colls)))

